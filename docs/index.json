[{"categories":["Writeups"],"content":"A writeup on Inside the matrix Challenge Information\rGiven materials: Get it here! Description: As you deciphered the Matrix, you discovered that the astronomy scientist had observed that certain stars were not real. He had created two 5x5 matrices with values based on the time the stars were bright, but after some time, the stars stopped emitting light. Nonetheless, he had managed to capture every matrix until then and created an algorithm that simulated their generation. However, he could not understand what was hidden behind them as he was missing something. He believed that if he could understand the stars, he would be able to locate the secret tombs where the relic was hidden. Category: Crypto - Easy The server script is shown below: from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b\"HTB{????????????????????}\" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.rotate() key = self.generate() message = self.parse(message) ciphertext = message * key return ciphertext, key def menu(): print(\"Options:\\n\") print(\"[L]ook at page\") print(\"[T]urn page\") print(\"[C]heat\\n\") option = input(\"\u003e \") return option def main(): book = Book() ciphertext, key = book.encrypt(FLAG) page_number = 1 while True: option = menu() if option == \"L\": # ascii_print(ciphertext, key, page_number) print(ciphertext, key, page_number) elif option == \"T\": ciphertext, key = book.encrypt(FLAG) page_number += 2 print() elif option == \"C\": print(f\"\\n{list(ciphertext)}\\n{list(key)}\\n\") else: print(\"\\nInvalid option!\\n\") if __name__ == \"__main__\": try: main() except Exception as e: print(f\"An error occurred: {e}\") ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:0:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Problem statement The code defines a class Book that is used to generate a key matrix and encrypt a message using matrix multiplication. The matrix is generated randomly each time a message is encrypted, and its size is fixed at $5\\times 5$. The program encrypts a flag, stored in FLAG, using the Book class and presents a menu to the user to interact with the encrypted flag. The main function of the code presents a menu to the user with three options: [L]ook at page: displays the ciphertext and key matrix for the current page number. Here is an example output when you choose this option: Options: [L]ook at page [T]urn page [C]heat \u003e L _________ _________ ______/ 5\\ / 6 \\_______ /| --------------- | --------------- |\\ || Ciphertext:--- - | Key:------------ ||| || ---------------- | ------ -------- ||| || ---------- ----- | ---------------- ||| || [3,12,21,20,8]-- | [18,18,21,26,24] ||| || [1,1,9,7,1]----- | [21,7,10,9,2]--- ||| || [10,3,8,6,13]--- | [22,1,24,22,12]- ||| || [0,19,24,15,12]- | [7,21,7,20,2]--- ||| || [10,4,6,2,4]---- | [26,25,17,3,25]- ||| || ---------------- | ------ ----- --- ||| || --- - ---------- | ---------------- ||| ||______________ _ | ________________||| L/______/---------\\\\_//W--------\\_______\\J [T]urn page: generates a new key matrix and ciphertext for the next page number. [C]heat: displays the ciphertext and key matrix in list type. The Cheat output of above example page is: [(3, 12, 21, 20, 8), (1, 1, 9, 7, 1), (10, 3, 8, 6, 13), (0, 19, 24, 15, 12), (10, 4, 6, 2, 4)] [(18, 18, 21, 26, 24), (21, 7, 10, 9, 2), (22, 1, 24, 22, 12), (7, 21, 7, 20, 2), (26, 25, 17, 3, 25)] ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:1:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Initial analysis ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:2:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Primes Prime $p$ is changed whenever Turn page option is chosen. Though we don’t know what $p$ is, we know that it would be from 16 to 64. There are 12 primes in this range, which are $17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61$. ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:2:1","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"The encryption It’s just a multiplication between two $5 \\times 5$ matrixs over the field of integers modulo $p$: $$C \\equiv M\\times K (\\text{mod } p)$$ $$\\Leftrightarrow M \\equiv C\\times K^{-1} (\\text{mod } p)$$ ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:2:2","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Conclusion We already have key $K$ and ciphertext $C$ by using Cheat option. Then if we know $p$, we can easily recover message $M$ in modulus $p$. Because $p$ is changeable, we can gather several pairs $(M_i, p_i)$ where $i \\geq 2$. ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:2:3","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Solution method Suppose there are some entries in a key $K_1$ which are larger than 59, then $p_1$ must be 61. Suppose all entries in a key $K_2$ are smaller than 17, then it’s likely that $p_2$ is 17. If we have $K_1$ and $K_2$, then we can recover $M_1$, $M_2$. By applying CRT (Chinese Remainder Theorem) for 2 pairs $(M_1, 61)$ and $(M_2, 17)$, we can get $M$ in modulus $61\\times 17 = 1037$. Because every entries of the actual message’s matrix are bytes, they would be smaller than 128 (which is much smaller than 1037). This means our $M$ is actually the message itself. So our mission is just to find $C_1, C_2$ by using Turn page many times. Here is the script after we gather enough materials (I used $p_1=61$ and $p_2=19$): M_1 = [11, 23, 5, 1, 47, 48, 48, 46, 34, 3, 55, 34, 55, 43, 51, 34, 54, 55, 52, 53, 54, 33, 33, 33, 3] M_2 = [15, 8, 9, 9, 13, 10, 10, 12, 0, 7,2, 0, 17, 9, 13,0, 1, 2, 14, 0,1, 14, 14, 14, 11] res = [] from sympy.ntheory.modular import crt for i in range(len(M_1)): m = [61, 19] v = [M_1[i], M_2[i]] # Use crt() method crt_m_v = crt(m, v)[0] res.append(crt_m_v) print(''.join([chr(x) for x in res])) ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:3:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"Results The Flag: HTB{l00k_@t_7h3_st4rs!!!} ","date":"2023-03-26","objectID":"/dashaus165blog/inside-the-matrix/:4:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Inside the matrix","uri":"/dashaus165blog/inside-the-matrix/"},{"categories":["Writeups"],"content":"A writeup on Multipage Recyclings Challenge Information\rGiven materials: Get it here! Description: As your investigation progressed, a clue led you to a local bar where you met an undercover agent with valuable information. He spoke of a famous astronomy scientist who lived in the area and extensively studied the relic. The scientist wrote a book containing valuable insights on the relic’s location, but encrypted it before he disappeared to keep it safe from malicious intent. The old man disclosed that the book was hidden in the scientist’s house and revealed two phrases that the scientist rambled about before vanishing. Category: Crypto - Easy The server script is shown below: from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.blockify(message, 16) for block in blocks: ct = self.cipher.encrypt(plaintext) encrypted_block = self.xor(block, ct) ciphertext += encrypted_block plaintext = encrypted_block return ciphertext def leak(self, blocks): r = random.randint(0, len(blocks) - 2) leak = [self.cipher.encrypt(blocks[i]).hex() for i in [r, r + 1]] return r, leak def main(): aes = CAES() message = pad(FLAG * 4, 16) ciphertext = aes.encrypt(message) ciphertext_blocks = aes.blockify(ciphertext, 16) r, leak = aes.leak(ciphertext_blocks) with open('output.txt', 'w') as f: f.write(f'ct = {ciphertext.hex()}\\nr = {r}\\nphrases = {leak}\\n') if __name__ == \"__main__\": main() We also have an output file: ct = bc9bc77a809b7f618522d36ef7765e1cad359eef39f0eaa5dc5d85f3ab249e788c9bc36e11d72eee281d1a645027bd96a363c0e24efc6b5caa552b2df4979a5ad41e405576d415a5272ba730e27c593eb2c725031a52b7aa92df4c4e26f116c631630b5d23f11775804a688e5e4d5624 r = 3 phrases = ['8b6973611d8b62941043f85cd1483244', 'cf8f71416111f1e8cdee791151c222ad'] ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:0:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"Problem statement This code defines a class called CAES that implements the AES encryption algorithm in ECB mode. The CAES class has methods to blockify a message into 16-byte blocks, xor two byte arrays, and encrypt a message using AES in ECB mode. Additionally, it has a method called leak that generates a random integer r and returns the encryption of two randomly chosen adjacent 16-byte blocks. The main function of this code creates an instance of the CAES class, generates a message by padded FLAG*4, encrypts the message, and generates a leak using the leak method of the CAES class. Finally, the main function writes the ciphertext, the randomly chosen integer r, and the leak to a file called output.txt. ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:1:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"Initial analysis ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:2:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"The encryption method The encrypt() method is not in ECB mode, it’s similar to CBC, which can be visualized by this graph: ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:2:1","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"The leaked data The leak method extracts 2 consecutives blocks of ciphertext and encrypted them using ECB mode. Our leaked data is of ciphertext block 3th and 4th. By using the graph above, we can easily see where the leak data comes from and how to use it to break the system, here is the new graph: ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:2:2","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"Solution method The work is simple, just to xor the c[4] with Leak[0] and xor c[5] with Leak[1], then we can recover the plaintext m[4] and m[5], respectively. They must be parts of, or entire flag (in any order). Here is the script: def xor(a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def blockify(message, size): return [message[i:i + size] for i in range(0, len(message), size)] ct = 'bc9bc77a809b7f618522d36ef7765e1cad359eef39f0eaa5dc5d85f3ab249e788c9bc36e11d72eee281d1a645027bd96a363c0e24efc6b5caa552b2df4979a5ad41e405576d415a5272ba730e27c593eb2c725031a52b7aa92df4c4e26f116c631630b5d23f11775804a688e5e4d5624' r = 3 Leak = ['8b6973611d8b62941043f85cd1483244', 'cf8f71416111f1e8cdee791151c222ad'] Leak = [bytes.fromhex(x) for x in Leak] c = blockify(ct, 32) c = [bytes.fromhex(x) for x in c] print(xor(c[4], Leak[0]) + xor(c[5], Leak[1])) ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:3:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"Results Here is the result: b'_w34k_w17h_l34kz}HTB{CFB_15_w34k' Then the final flag would be: HTB{CFB_15_w34k_w34k_w17h_l34kz} ","date":"2023-03-24","objectID":"/dashaus165blog/multipage-recyclings/:4:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Multipage Recyclings","uri":"/dashaus165blog/multipage-recyclings/"},{"categories":["Writeups"],"content":"A writeup on Perfect Synchronization Challenge Information\rGiven materials: Get it here! Description: The final stage of your initialization sequence is mastering cutting-edge technology tools that can be life-changing. One of these tools is quipqiup, an automated tool for frequency analysis and breaking substitution ciphers. This is the ultimate challenge, simulating the use of AES encryption to protect a message. Can you break it? Category: Crypto - Very Easy The encyption script is shown below: from os import urandom from Crypto.Cipher import AES from secret import MESSAGE assert all([x.isupper() or x in '{_} ' for x in MESSAGE]) class Cipher: def __init__(self): self.salt = urandom(15) key = urandom(16) self.cipher = AES.new(key, AES.MODE_ECB) def encrypt(self, message): return [self.cipher.encrypt(c.encode() + self.salt) for c in message] def main(): cipher = Cipher() encrypted = cipher.encrypt(MESSAGE) encrypted = \"\\n\".join([c.hex() for c in encrypted]) with open(\"output.txt\", 'w+') as f: f.write(encrypted) if __name__ == \"__main__\": main() ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:0:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Problem statement The Python script defines a Cipher class that generates a random salt and key, then encrypts a message using AES in ECB mode. The encrypted message is written to a file in hexadecimal format. The MESSAGE variable is imported from a separate file. Our mission is to recover the encrypted message and find the flag in it. ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:1:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Initial analysis ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:2:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"The randomness The author adds some randomnesses including key and salt to make the encryption more unpredictable. But if you look more closely into it, you will realize that the salt is just initialized once, and be padded for all characters in the message. It means the salt is not too much useful, it just shifts all characters by a constant value. ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:2:1","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"The AES encryption mode The author uses EBC mode - the weakest mode, to encrypt all shifted characters of the message. FYI\rFor anyone who doesn’t know about ECB: ECB (Electronic Codebook) is one of the simplest modes of AES encryption, where each block of plaintext is encrypted separately using the same key. In this mode, identical plaintext blocks will be encrypted to identical ciphertext blocks, making it vulnerable to attacks that exploit patterns in the plaintext. Therefore, ECB mode is not recommended for secure communication, and other modes like CBC, CTR, or GCM are preferred. A visualized example is illustrated in this wiki to show that AES-ECB mode is not semantically secure.\r","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:2:2","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Conclusion By the above analysis, we can prove that: For every $c_A, c_B \\in \\text{message}$: $c_A = c_B \\Leftrightarrow ECB(c_A + \\text{salt}) = ECB(c_B + \\text{salt})$ This means the encryption is just a substitution cipher. ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:2:3","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Solution method For simplicity in frequency analyzing, I map every different hex strings in the output file to a character (A-Z, 1-4), noted that identical strings would produce identical characters. By comparing to English Letter Frequency (including space character) table, we may recover some common letters like e, t, i, a, o confidentally. Then, by the reduncancy and meaning of English words, I can recover the entire content and find the flag. ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:3:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Results After the mapping, here is the encrypted message: Encrypted message\rABCDECFGHIJFJKHLMLIMLINJLCOIPFIQRCIAJGQIQRJQIMFIJFHISMTCFILQBCQGRIPAIVBMQQCFIKJFSEJSCIGCBQJMFIKCQQCBLIJFOIGPUNMFJQMPFLIPAIKCQQCBLIPGGEBIVMQRITJBHMFSIABCDECFGMCLIUPBCPTCBIQRCBCIMLIJIGRJBJGQCBMLQMGIOMLQBMNEQMPFIPAIKCQQCBLIQRJQIMLIBPESRKHIQRCILJUCIAPBIJKUPLQIJKKILJUWKCLIPAIQRJQIKJFSEJSCIMFIGBHWQJFJKHLMLIABCDECFGHIJFJKHLMLIJKLPIXFPVFIJLIGPEFQMFSIKCQQCBLIMLIQRCILQEOHIPAIQRCIABCDECFGHIPAIKCQQCBLIPBISBPEWLIPAIKCQQCBLIMFIJIGMWRCBQCYQIQRCIUCQRPOIMLIELCOIJLIJFIJMOIQPINBCJXMFSIGKJLLMGJKIGMWRCBLIABCDECFGHIJFJKHLMLIBCDEMBCLIPFKHIJINJLMGIEFOCBLQJFOMFSIPAIQRCILQJQMLQMGLIPAIQRCIWKJMFQCYQIKJFSEJSCIJFOILPUCIWBPNKCUILPKTMFSILXMKKLIJFOIMAIWCBAPBUCOINHIRJFOIQPKCBJFGCIAPBICYQCFLMTCIKCQQCBINPPXXCCWMFSIOEBMFSIVPBKOIVJBIMMINPQRIQRCINBMQMLRIJFOIQRCIJUCBMGJFLIBCGBEMQCOIGPOCNBCJXCBLINHIWKJGMFSIGBPLLVPBOIWEZZKCLIMFIUJ1PBIFCVLWJWCBLIJFOIBEFFMFSIGPFQCLQLIAPBIVRPIGPEKOILPKTCIQRCUIQRCIAJLQCLQILCTCBJKIPAIQRCIGMWRCBLIELCOINHIQRCIJYMLIWPVCBLIVCBCINBCJXJNKCIELMFSIABCDECFGHIJFJKHLMLIAPBICYJUWKCILPUCIPAIQRCIGPFLEKJBIGMWRCBLIELCOINHIQRCI1JWJFCLCIUCGRJFMGJKIUCQRPOLIPAIKCQQCBIGPEFQMFSIJFOILQJQMLQMGJKIJFJKHLMLISCFCBJKKHIRQN2J3LMUWKC3LENLQMQEQMPF3ML3VCJX4IGJBOIQHWCIUJGRMFCBHIVCBCIAMBLQIELCOIMFIVPBKOIVJBIMMIWPLLMNKHINHIQRCIELIJBUHLILMLIQPOJHIQRCIRJBOIVPBXIPAIKCQQCBIGPEFQMFSIJFOIJFJKHLMLIRJLINCCFIBCWKJGCOINHIGPUWEQCBILPAQVJBCIVRMGRIGJFIGJBBHIPEQILEGRIJFJKHLMLIMFILCGPFOLIVMQRIUPOCBFIGPUWEQMFSIWPVCBIGKJLLMGJKIGMWRCBLIJBCIEFKMXCKHIQPIWBPTMOCIJFHIBCJKIWBPQCGQMPFIAPBIGPFAMOCFQMJKIOJQJIWEZZKCIWEZZKCIWEZZKC\rPlotting the histogram of this encrypted message, comparing with the expected frequency, we get: Here is the script, if you’re interested in: import matplotlib.pyplot as plt def plot_histogram(text): english_freq = {'space': 0.18316895740067898, 'e': 0.10266650309881365, 't': 0.07516918822929543, 'a': 0.0653211522431101, 'o': 0.06165021261170107, 'i': 0.06109938076429621, 'n': 0.05748993391266301, 's': 0.0558094607431706, 'r': 0.05501226388301501, 'h': 0.0418265243918537, 'l': 0.03203162615518401, 'd': 0.03123691335535358, 'u': 0.02074798285524714, 'c': 0.020576050425919314, 'm': 0.019830666456506605, 'f': 0.016535714836861396, 'w': 0.015818636195592536, 'g': 0.014126275726274115, 'p': 0.01318902368984632, 'y': 0.012614330285168858, 'b': 0.010748157780246267, 'v': 0.007961080746834234, 'k': 0.005609987561400249, 'x': 0.0012367402118007968, 'j': 0.0010975645567653538, 'q': 0.0010065039671926798, 'z': 0.0005273232293542625} char_dict = {} for char in text: if char in char_dict: char_dict[char] += 1 else: char_dict[char] = 1 for key in char_dict: char_dict[key] /= len(text) # char_dict[key] *= 100 char_dict = dict(sorted(char_dict.items(), key=lambda x: x[1], reverse=True)) # plt.bar(char_dict.keys(), char_dict.values()) fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1) # Plot the first subplot ax1.bar(char_dict.keys(), char_dict.values()) ax1.set_xlabel('Encrypted message') ax1.set_ylabel('Frequency (%)') # Plot the second subplot ax2.bar(english_freq.keys(), english_freq.values()) ax2.set_xlabel('English') ax2.set_ylabel('Frequency (%)') plt.show() Based on the charts, we can easily find that letter I, C in encrypted message must be space and e in English, respectively. I guess there must be one and only one pair {} in the message for the flag HTB{...}. In the above chart, letter 2 and 4 share the smallest frequency, so they must be { and }. Moreover, the 3 characters immediately preceding { must be htb. After that, we got: Message\rABeDEeFGH JFJKHLML ML bJLeO PF the AJGt thJt MF JFH SMTeF LtBetGh PA VBMtteF KJFSEJSe GeBtJMF KetteBL JFO GPUbMFJtMPFL PA KetteBL PGGEB VMth TJBHMFS ABeDEeFGMeL UPBePTeB theBe ML J GhJBJGteBMLtMG OMLtBMbEtMPF PA KetteBL thJt ML BPEShKH the LJUe APB JKUPLt JKK LJUWKeL PA thJt KJFSEJSe MF GBHWtJFJKHLML ABeDEeFGH JFJKHLML JKLP XFPVF JL GPEFtMFS KetteBL ML the LtEOH PA the ABeDEeFGH PA KetteBL PB SBPEWL PA KetteBL MF J GMWheBteYt the UethPO ML ELeO JL JF JMO tP bBeJXMFS GKJLLMGJK","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:4:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"Conclusion This challenge is just a substitution cipher, which is totally insecure against frequency analysis. The random key, salt, AES-ECB is just to make colors :D. ","date":"2023-03-24","objectID":"/dashaus165blog/perfect-synchronization/:5:0","tags":["writeups","crypto","htb"],"title":"Cyber Apocalypse 2023: Perfect Synchronization","uri":"/dashaus165blog/perfect-synchronization/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Collector","date":"2023-03-10","objectID":"/dashaus165blog/collector/","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Collector Challenge Information\rGiven materials: Get it here! Host: 52.59.124.14:10005 Description: Bob is hosting a party and invited everyone but me. But all the invitations I can collect are encrypted. Category: Crypto The encyption code is shown below: from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, long_to_bytes from hashlib import sha256 import random from secret import flag # Parameters N = 2048 hLen = 256 def MGF(seed, length): random.seed(seed) return [random.randint(0,255) for _ in range(length)] def pad(stream, bitlength, tag = b''): seed = sha256(stream).digest() DB = sha256(tag).digest() + b'\\x00' * ((bitlength - 16 - 2*hLen) // 8 - len(stream)) + b'\\x01' + stream mask = MGF(seed, len(DB)) maskedDB = [DB[i] ^ mask[i] for i in range(len(DB))] seedmask = MGF(bytes_to_long(bytes(maskedDB)), hLen // 8) masked_seed = [seed[i] ^ seedmask[i] for i in range(hLen // 8)] EM = [0] + masked_seed + maskedDB return bytes(EM) key = RSA.generate(N, e = (1\u003c\u003c(1\u003c\u003crandom.randint(0,4))) + 1) msg = pad(flag, N) cipher = pow(bytes_to_long(msg), key.e, key.n) print(key.publickey().export_key()) print(hex(cipher)) Every time we connect to the host (via netcat or sth), we will receive a different ciphertext encrypted by a random modulus and public key. Note that the message is not change. Our work is finding the message, then unpad it. The padding scheme is a little bit complicated. We will kill it later. At first we will retrieve the message. ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:0:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Find the message Look at the randomization of public key e = (1\u003c\u003c(1\u003c\u003crandom.randint(0,4))) + 1. This means e must be equal to $2^{2^x} + 1$ for some integers $x \\in [0, 4]$. At some times e could be very small like 3 or 5. Because the message is unchanged, we can use the Chinese Remainder Theorem (CRT) to break this when gathering enough ciphertexts. I repeatedly connected to the remote until having 3 ciphertexts with e = 3. e = 3 N = [28381641470468894491803213061106255342394785960384941880077041220424858882243977178327833510813856252123826746136803591828086299475087806054298840171844435617137577385214546313958620567553253217307660746834119848698440453807137028548358408609717898329618640526221733866656561521129647023240413028643353478087055828259789123943016979435211452647807696304538852270445595330922933463828624035948430989311305830380036909110401405096121447796742654166842393747308740780904196329123383973796349621094915042791540207331450449802592104266984813731468139429699360268971982017419995340593646178732193351256580686583645074686481, 28436672769421092594548202063747136916010694256439596421267256338356642110615214295636290262174422091110004588277589357833064734842830005906601043923191160888729742432170304483250917430300469828737729147336593221799075533669151807403536631518772213122496331705583686028383255398390202874974738970297256383620164410474840284541812020710089537740738125841696533411618103247902091800590243557503164318811200241072268218187996587800580083415291553258227269481299061378559085130925905173961445149171436522574889242127165031893466792518949839440702289685992727216675856642620509410556237355496471530737288787259785052322993, 25412404546346468305392035193378764251619897130524613049803135516536070315326552786305399441669596628056673371439515815781250907753718067067226518798529940898970567077537254185822862662220847912618660781287259157242149100209572603742637992436899975356747571153179206867731331643050831867936881069006927570181727198234072053231467970543502983704951535677566284955370022801304229992130157161656559459468967395896136014632983809461559912693283225883003846877844569910763540763884040047237999313928073272402379600504681309154175040711570175227656258694170595021901919042033878632991260113162504162300983314586289440358641] c = [0xdfccaaeb5849c7e9b01d597255e1e77b3d6d441560e523074d024c79dfb61484c821c36e4f7ff4ca164cfd6112c904943a35926c7dffcd095567cf6421a027e83adcfa63be84a2407c5bd27d9e66679bb18d638cfb842301001ec0c760d455f376882f286b8f684a3b9270d4b9cd7288c21a983cb4364866e2553bacfd07b486a54fb0ea68f97c538aa83ec50074cb1d39277aa9976e6e29fbcc497ef1bcbea19029139c94f127c48092105f1fdd70cd007dfc70b853a999c6b1869573fdef7a53c1e2161734d13e3960a3c8b07f08098e2e197d2727cd6eadcc6b1132162ea4165c69f681bc30bf50fcfa98316ccddf4b2680d11017b53fd848899cac536476, 0x9c75253abd2f6112ccf8dc68b94a636dab7b97dbee4e827c458c53ef0ec07f88e9198c7c4c0bc2b12c045268dff6b7f4902315644112c80602fb234721cf17294bd5aac3bfac2260037bd1442198ad31b2654b8fdbf91df94cc18c761288e092a86f40abfa417a6ce29ef993a8454b001889f2b4fd3af240adb6ecdf18b1055ff1713b12a2163f6bf9421db1709863e5557354acd6cf4b806f9cb7252750a5654ba30da2a58e64c7116d7a97bdeb428cf1041e6506f989ee785313827ed054ba9da7064fcc1cdaf4550de966a1cf6a043d5870c80f182876e3cb78fb40ef1d90d32499c838e4f7da0b0fc0c3365384040eca1beb2879438f8aa6893439eb6241, 0x39d8ca6d816ae44c9c5785265ed276fc162e3c09d16a83398975af4b41e80e794acbb2ff2514b78d9de37933f89fc4df30f5eea0a58338d0b6390d72f33acd62587aec18b0a9f03627ae368b6f7c6243853084fe27f72cc3b7fd2eabee080cbb73d9bd561d566c2443aca2dadf0340d5cd69a7c18071c79345600239417ce8ec81b24b52b23f42e95e2d1c0cd40c9fb5b6c984ab7971a843f8d29cff2768f8df6b051d4f804bd858e6b8963c987dc39c9d03ef447b43991c4a6851e027b8479aa092e91b46803507a330915b71450b8e0e3714b92c1f8bc0b9b363de8565b48a68616f0aedf9e64b588828cff530c909dabf889decaead068de12aee635ad14e] So we have $c_i$ sastifies $c_i \\equiv \\text{msg}^3 \\text{ (mod }N_i)$ for $i = 0, 1, 2$. Then using CRT to find $X$ that sastifies $X \\equiv \\text{ms","date":"2023-03-10","objectID":"/dashaus165blog/collector/:1:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Unpad the message Although there’re randomizations in this unpadding scheme, I quickly recognize that it allows me to set the seed, so the random function is not random anymore. We know the seed, we know all! I will act like an amateur reverse engineer: just read what the code does and do reversely, hehe. For visualization, I’ve drawn a process of the reversing: Here is my code: msg = long_to_bytes(msg) msg = list(msg) masked_seed = msg[1: 1 + (hLen//8)] maskedDB = msg[1 + hLen//8:] seedmask = MGF(bytes_to_long(bytes(maskedDB)), hLen // 8) seed = [masked_seed[i] ^ seedmask[i] for i in range(hLen // 8)] mask = MGF(bytes(seed), len(maskedDB)) DB = [maskedDB[i] ^ mask[i] for i in range(len(maskedDB))] print(bytes(DB)) Unfortunately, it didn’t work: b\"\\xa2+\\x14\\x9e1\\x8e\\xa4\\xb5h \\xa8\\x80\\x9b?\\xae\\xe3\\xe1L\\xfc\\xbb\\x9cB_\\xb3P\\x19\\xcb\\xbfy\\xe54'\\xd2~\\x98C \\xcd\\x03\\xf0\\xd3\\x82K\\x05\\xfeT\\xbc\\xe4\\xcc\\xf5V6}\\x1ds\\xe9@)_o\\xea\\xd2\\xbb\\x00\\x7f\\xd9\\xcd\\xef5\\xe3\\x88\\x00#p41\\xc9wG\\xdbKl\\xd233\\x83'\\x13#\\x1c\\x97\\xc1_\\xd0xn\\x0b\\xd8p\\x89_\\xde\\x98\\xcb\\xb0o\\xd6J\\xb8\\x1cC\\xad\\xa2\\x9bEe\\x0f\\xf1\\x81\\xfd\\xa6G\\xc7S\\x1d\u0026b\\xe8\\x0b5\\xea\\x10\\x9av\\x95\\xe0\\xa5t=\\xdd^?\\xa4.\\x1cd\\x0bm=\\x8b\\x0bS\\x1aK\\xff\\xbf\\xd1\\x02\\n\\x82\\xd4B\\x17B*kBGP\\xbfN\\xd3C!\\x01\\x82\\x05\\xee_(\\xd9m]\\xd1^\\x9bkF\\xa0,\\xe6\\x17X\\xc6\\xee\\x9a\\xab\\xa6\\x96\\xfd\\x08\\x16\\xaf\\xce\\x89\\xeb\\xd8\\x8av\\xbb\\xe0\\xda\\xe4\\x00\\xad\\x08\\xect\\x87jE3\" That is because of the line EM = [0] + masked_seed + maskedDB. When we add prefix 0x00, convert it to long and then convert it back to bytes, the prefix will gone. a = [0] + [5] + [7] a = bytes(a) print(a) # b'\\x00\\x05\\x07' b = bytes_to_long(a) print(long_to_bytes(b)) # b'\\x05\\x07' So I add one null byte to my msg manually: msg = [0] + list(msg). Here is the result after re-run the script: b\"\\xe3\\xb0\\xc4B\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99o\\xb9$'\\xaeA\\xe4d\\x9b\\x93L\\xa4\\x95\\x99\\x1bxR\\xb8U\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01ENO{com3_to_Nu1lCon_bu1_do_n0t_tel1_B0b}\" The flag is at the end of this output: ENO{com3_to_Nu1lCon_bu1_do_n0t_tel1_B0b} ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:2:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Conclusion This is an easy crypto challange, but consisting RE technique makes it valuable for me. ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:3:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Breaking news","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Breaking news Challenge Information\rGiven materials: Get it here! Description: Alice started to encrypt the flag, but realised halfway she was unhappy with her key. So she created a new one. Category: Crypto The encyption code is shown below: from Crypto.PublicKey import RSA from secret import flag from Crypto.Cipher import PKCS1_OAEP from Crypto.Util.number import inverse from binascii import hexlify key1 = RSA.import_key(open('key1.pem','rb').read()) key2 = RSA.import_key(open('key2.pem','rb').read()) msg1 = flag[:len(flag)//2] msg2 = flag[len(flag)//2:] cryptor = PKCS1_OAEP.new(key1) c1 = cryptor.encrypt(msg1) cryptor = PKCS1_OAEP.new(key2) c2 = cryptor.encrypt(msg2) writer = open('ciphers','wb') writer.write(hexlify(c1) + b'\\n' + hexlify(c2)) writer.close() The ciphertexts: c1 = \"3b6ccd7fa1de0455945998bc024adc6c2b60ccc8f020cbf024c3d4f98eafdf6a43afd15ec4d9a32f84cb61f7a5462547f2e3622b547c3e9ccb723102805544b373a80f4d252a1081db6d5c5499b222093fd4bb7997c68ab0ed8a9ac3bd0dae64cdfb946da1e311ef6e216ddf2dac14ea3710d5622269f08073598c24a3000a6dd6270ca0db5c304102bc9a5cd104484a2c0ced339121f13499c795de343ad2e655d4ace726654ee9f110e4bee3db95d8e514bd6e658769a01638ff2e9ce954dc09def3b01f6d598ddae2ca9735c8e8f9b71c96984a114084fb0a25b3646481e8c8d4d8adfedc7afad7be7a009c6d12753db4216ab9fd7fc8c37c819aef6a8bce\" c2 = \"998d5eeb0c048ade8cd807cb582b15a7799e8481a7476dbe8e0310b5ffc5161add92539bc0a374333c11f5f2008195782a44e45f2394fe3115af59fbc73ad24c4d084d79ba8e5896b644917335fd9a0e07c1d1d316e50480ba44c67b6fc04a2ce33dbc721768f1f874ff2ce1ec0503a4a7c67d10119ff9f79030459068de24ff24593e16877fd74c5a12d0e64a3d62e61b13c403aad2fe605601e8a097aba99707e305e3125a3c89f3d6beccc2f19a32fdac9ab7df181938b9b80d83a54c9c23ef11affff0fca67ecd9d45c58ece90a44ecd60aff7be05bf97cb554c563a3f9139d99f7c76a07acaaa261b1d6cb41e228fb2aca02ed1c64d468aabb8cfaa9210\" It seems that the encryption of the first and the last half of flag is not relevant. But at least we should check the public key and the modulus of key1.pem and key2.pem. from Crypto.PublicKey import RSA key1 = RSA.import_key(open('breaking_news\\key1.pem','rb').read()) key2 = RSA.import_key(open('breaking_news\\key2.pem','rb').read()) e1 = key1.e e2 = key2.e n1 = key1.n n2 = key2.n e1 (bit_length = 2045): 2726678763069742290493975678771854042946997886526658885273589794982550850524484749274268692898909814780790152954912126546903921714367517303032050244891472514523849708519935681313568761427297382724990480371626349446130805480456004417663238567505831802110513475009108333474503714942886902760554023856774744528158730164306665386046820676766827602146514316823937019543742466850364749529076296428648908924805389552335245924389342424467024736023185451341764743413642429057857014342930366786601460889647066379811076861622890568687138322791084455379633576246829677348537342669805283721207716632578516825617674863582898823857 n1 (bit_length = 2048): 22446667384135380364728550075881381726053468195188168013152415796352249451953078762739428049146187827398120100488504055606635548019009256889092903583429161620832130884808020463159053237738268615549212998960185401460575049040129569674912795281010462969369309454450379821434551440286230754665181962106098655531061808191857271372118647412341530534507363035768520018955713235360762429287435263772391386477249961479679573552073377992778864273735159890546438757223394182339510136036600928909879322891169743059815434712294601960066048614718984000476293007036534025674690519367295530441293542361110626472198678166093083778539 e2 (bit_length = 2047): 1025614691538937680473350384937839404022673831543804873390821235642349784468976380689985141971347728145167220859932279361921851630754436084881310527467399581064169495199510518576682055075870988700464507436921496419813225182888368322755063851582948247904399276524553429044729402973825513752800743408745783376473721224429168610790081938366519110824829336786992193261655888040783602954129146564842167332117396899423321041617438046837454077677830936561","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:0:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"The first half I tried and happily it’s broken by the Wiener Attack. For the Wiener Attack, readers should read this. Here is the code: import owiener N = n1 try: d1 = owiener.attack(e1, N) k1 = RSA.construct((N, e1, d1)) cryptor1 = PKCS1_OAEP.new(k1) c1 = bytes.fromhex(c1) print(cryptor1.decrypt(c1)) except: print(\"Failed\") The library owiener is in this repo. Result: b'ENO{n3ver_reus3_your_pr1mes_4_a_' ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:1:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"The last half The last half is not that easy. I tried the same attack and it failed. But maybe we can exploit some properties from known key (e1, d1) in the previous section. Fortunately, it does! Based on this paper of Prof. Dan Boneh, the factorization of $N$ can be computed in polynomial time when we’re given one pair (e, d). One implementation of this fast-factor algorithm is available in this repo. I made a tiny optimization in operator to make it works with big numbers, you can try to guess what it is, hehe. Here is the code: p, q = factor(N, e1, d1) phi = (p - 1) * (q - 1) d2 = inverse(e2, phi) k2 = RSA.construct((N, e2, d2)) cryptor2 = PKCS1_OAEP.new(k2) print(cryptor1.decrypt(c1) + cryptor2.decrypt(c2)) The final result: b'ENO{n3ver_reus3_your_pr1mes_4_a_new_k3y_you_have_2_p4y_th3_pr1ce}' ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:2:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"Conclusion This challange is very helpful to me, because it contains many (2) attacks that I forgot. It’s a nice chance to review RSA! ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:3:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/dashaus165blog/about/","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Some Background Informations I am Hao Pham-Duc (dasHaus165), a Cryptographer from the Bach Khoa Information Security Club (BKISC), Ho Chi Minh City University of Technology (HCMUT). ","date":"0001-01-01","objectID":"/dashaus165blog/about/:1:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Interests Applied Cryptography Machine Learning Classical and Quantum Physics ","date":"0001-01-01","objectID":"/dashaus165blog/about/:2:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Achievements Nothing yet. ","date":"0001-01-01","objectID":"/dashaus165blog/about/:3:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Contact Me You can contact me via Email or Github. ","date":"0001-01-01","objectID":"/dashaus165blog/about/:4:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"}]