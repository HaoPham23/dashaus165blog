[{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Collector","date":"2023-03-10","objectID":"/dashaus165blog/collector/","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Collector Challenge Information\rGiven materials: Get it here! Host: 52.59.124.14:10005 Description: Alice started to encrypt the flag, but realised halfway she was unhappy with her key. So she created a new one. Category: Crypto The encyption code is shown below: from Crypto.PublicKey import RSA from Crypto.Util.number import bytes_to_long, long_to_bytes from hashlib import sha256 import random from secret import flag # Parameters N = 2048 hLen = 256 def MGF(seed, length): random.seed(seed) return [random.randint(0,255) for _ in range(length)] def pad(stream, bitlength, tag = b''): seed = sha256(stream).digest() DB = sha256(tag).digest() + b'\\x00' * ((bitlength - 16 - 2*hLen) // 8 - len(stream)) + b'\\x01' + stream mask = MGF(seed, len(DB)) maskedDB = [DB[i] ^ mask[i] for i in range(len(DB))] seedmask = MGF(bytes_to_long(bytes(maskedDB)), hLen // 8) masked_seed = [seed[i] ^ seedmask[i] for i in range(hLen // 8)] EM = [0] + masked_seed + maskedDB return bytes(EM) key = RSA.generate(N, e = (1\u003c\u003c(1\u003c\u003crandom.randint(0,4))) + 1) msg = pad(flag, N) cipher = pow(bytes_to_long(msg), key.e, key.n) print(key.publickey().export_key()) print(hex(cipher)) Every time we connect to the host (via netcat or sth), we will receive a different ciphertext encrypted by a random modulus and public key. Note that the message is not change. Our work is finding the message, then unpad it. The padding scheme is a little bit complicated. We will kill it later. At first we will retrieve the message. ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:0:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Find the message Look at the randomization of public key e = (1\u003c\u003c(1\u003c\u003crandom.randint(0,4))) + 1. This means e must be equal to $2^{2^x} + 1$ for some integers $x \\in [0, 4]$. At some times e could be very small like 3 or 5. Because the message is unchanged, we can use the Chinese Remainder Theorem (CRT) to break this when gathering enough ciphertexts. I repeatedly connected to the remote until having 3 ciphertexts with e = 3. e = 3 N = [28381641470468894491803213061106255342394785960384941880077041220424858882243977178327833510813856252123826746136803591828086299475087806054298840171844435617137577385214546313958620567553253217307660746834119848698440453807137028548358408609717898329618640526221733866656561521129647023240413028643353478087055828259789123943016979435211452647807696304538852270445595330922933463828624035948430989311305830380036909110401405096121447796742654166842393747308740780904196329123383973796349621094915042791540207331450449802592104266984813731468139429699360268971982017419995340593646178732193351256580686583645074686481, 28436672769421092594548202063747136916010694256439596421267256338356642110615214295636290262174422091110004588277589357833064734842830005906601043923191160888729742432170304483250917430300469828737729147336593221799075533669151807403536631518772213122496331705583686028383255398390202874974738970297256383620164410474840284541812020710089537740738125841696533411618103247902091800590243557503164318811200241072268218187996587800580083415291553258227269481299061378559085130925905173961445149171436522574889242127165031893466792518949839440702289685992727216675856642620509410556237355496471530737288787259785052322993, 25412404546346468305392035193378764251619897130524613049803135516536070315326552786305399441669596628056673371439515815781250907753718067067226518798529940898970567077537254185822862662220847912618660781287259157242149100209572603742637992436899975356747571153179206867731331643050831867936881069006927570181727198234072053231467970543502983704951535677566284955370022801304229992130157161656559459468967395896136014632983809461559912693283225883003846877844569910763540763884040047237999313928073272402379600504681309154175040711570175227656258694170595021901919042033878632991260113162504162300983314586289440358641] c = [0xdfccaaeb5849c7e9b01d597255e1e77b3d6d441560e523074d024c79dfb61484c821c36e4f7ff4ca164cfd6112c904943a35926c7dffcd095567cf6421a027e83adcfa63be84a2407c5bd27d9e66679bb18d638cfb842301001ec0c760d455f376882f286b8f684a3b9270d4b9cd7288c21a983cb4364866e2553bacfd07b486a54fb0ea68f97c538aa83ec50074cb1d39277aa9976e6e29fbcc497ef1bcbea19029139c94f127c48092105f1fdd70cd007dfc70b853a999c6b1869573fdef7a53c1e2161734d13e3960a3c8b07f08098e2e197d2727cd6eadcc6b1132162ea4165c69f681bc30bf50fcfa98316ccddf4b2680d11017b53fd848899cac536476, 0x9c75253abd2f6112ccf8dc68b94a636dab7b97dbee4e827c458c53ef0ec07f88e9198c7c4c0bc2b12c045268dff6b7f4902315644112c80602fb234721cf17294bd5aac3bfac2260037bd1442198ad31b2654b8fdbf91df94cc18c761288e092a86f40abfa417a6ce29ef993a8454b001889f2b4fd3af240adb6ecdf18b1055ff1713b12a2163f6bf9421db1709863e5557354acd6cf4b806f9cb7252750a5654ba30da2a58e64c7116d7a97bdeb428cf1041e6506f989ee785313827ed054ba9da7064fcc1cdaf4550de966a1cf6a043d5870c80f182876e3cb78fb40ef1d90d32499c838e4f7da0b0fc0c3365384040eca1beb2879438f8aa6893439eb6241, 0x39d8ca6d816ae44c9c5785265ed276fc162e3c09d16a83398975af4b41e80e794acbb2ff2514b78d9de37933f89fc4df30f5eea0a58338d0b6390d72f33acd62587aec18b0a9f03627ae368b6f7c6243853084fe27f72cc3b7fd2eabee080cbb73d9bd561d566c2443aca2dadf0340d5cd69a7c18071c79345600239417ce8ec81b24b52b23f42e95e2d1c0cd40c9fb5b6c984ab7971a843f8d29cff2768f8df6b051d4f804bd858e6b8963c987dc39c9d03ef447b43991c4a6851e027b8479aa092e91b46803507a330915b71450b8e0e3714b92c1f8bc0b9b363de8565b48a68616f0aedf9e64b588828cff530c909dabf889decaead068de12aee635ad14e] So we have $c_i$ sastifies $c_i \\equiv \\text{msg}^3 \\text{ (mod }N_i)$ for $i = 0, 1, 2$. Then using CRT to find $X$ that sastifies $X \\equiv \\text{ms","date":"2023-03-10","objectID":"/dashaus165blog/collector/:1:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Unpad the message Although there’re randomization in this unpadding scheme, I quickly recognize that it allows me to set the seed, so the random function is not random anymore. We know the seed, we know all! I will act like an amateur reversed engineer, read what the code does and do reversely hehe. For visualization, I draw a process for my code: Here is my code: msg = long_to_bytes(msg) msg = list(msg) masked_seed = msg[1: 1 + (hLen//8)] maskedDB = msg[1 + hLen//8:] seedmask = MGF(bytes_to_long(bytes(maskedDB)), hLen // 8) seed = [masked_seed[i] ^ seedmask[i] for i in range(hLen // 8)] mask = MGF(bytes(seed), len(maskedDB)) DB = [maskedDB[i] ^ mask[i] for i in range(len(maskedDB))] print(bytes(DB)) Unfortunately, it didn’t work: b\"\\xa2+\\x14\\x9e1\\x8e\\xa4\\xb5h \\xa8\\x80\\x9b?\\xae\\xe3\\xe1L\\xfc\\xbb\\x9cB_\\xb3P\\x19\\xcb\\xbfy\\xe54'\\xd2~\\x98C \\xcd\\x03\\xf0\\xd3\\x82K\\x05\\xfeT\\xbc\\xe4\\xcc\\xf5V6}\\x1ds\\xe9@)_o\\xea\\xd2\\xbb\\x00\\x7f\\xd9\\xcd\\xef5\\xe3\\x88\\x00#p41\\xc9wG\\xdbKl\\xd233\\x83'\\x13#\\x1c\\x97\\xc1_\\xd0xn\\x0b\\xd8p\\x89_\\xde\\x98\\xcb\\xb0o\\xd6J\\xb8\\x1cC\\xad\\xa2\\x9bEe\\x0f\\xf1\\x81\\xfd\\xa6G\\xc7S\\x1d\u0026b\\xe8\\x0b5\\xea\\x10\\x9av\\x95\\xe0\\xa5t=\\xdd^?\\xa4.\\x1cd\\x0bm=\\x8b\\x0bS\\x1aK\\xff\\xbf\\xd1\\x02\\n\\x82\\xd4B\\x17B*kBGP\\xbfN\\xd3C!\\x01\\x82\\x05\\xee_(\\xd9m]\\xd1^\\x9bkF\\xa0,\\xe6\\x17X\\xc6\\xee\\x9a\\xab\\xa6\\x96\\xfd\\x08\\x16\\xaf\\xce\\x89\\xeb\\xd8\\x8av\\xbb\\xe0\\xda\\xe4\\x00\\xad\\x08\\xect\\x87jE3\" That is because the line EM = [0] + masked_seed + maskedDB. When we add prefix 0x00, convert it to long and then convert it back to bytes, the prefix will gone. a = [0] + [5] + [7] a = bytes(a) print(a) # b'\\x00\\x05\\x07' b = bytes_to_long(a) print(long_to_bytes(b)) # b'\\x05\\x07' So I add one null byte to my msg manually: msg = [0] + list(msg). Here is the result after re-run the script: b\"\\xe3\\xb0\\xc4B\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99o\\xb9$'\\xaeA\\xe4d\\x9b\\x93L\\xa4\\x95\\x99\\x1bxR\\xb8U\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01ENO{com3_to_Nu1lCon_bu1_do_n0t_tel1_B0b}\" The flag is at the end of this output: ENO{com3_to_Nu1lCon_bu1_do_n0t_tel1_B0b} ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:2:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"Conclusion This is an easy crypto challange, but consisting RE technique makes it is valuable with me. ","date":"2023-03-10","objectID":"/dashaus165blog/collector/:3:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: collector","uri":"/dashaus165blog/collector/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Breaking news","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"A writeup on nullcon CTF 2023 - Breaking news Challenge Information\rGiven materials: Get it here! Description: Alice started to encrypt the flag, but realised halfway she was unhappy with her key. So she created a new one. Category: Crypto The encyption code is shown below: from Crypto.PublicKey import RSA from secret import flag from Crypto.Cipher import PKCS1_OAEP from Crypto.Util.number import inverse from binascii import hexlify key1 = RSA.import_key(open('key1.pem','rb').read()) key2 = RSA.import_key(open('key2.pem','rb').read()) msg1 = flag[:len(flag)//2] msg2 = flag[len(flag)//2:] cryptor = PKCS1_OAEP.new(key1) c1 = cryptor.encrypt(msg1) cryptor = PKCS1_OAEP.new(key2) c2 = cryptor.encrypt(msg2) writer = open('ciphers','wb') writer.write(hexlify(c1) + b'\\n' + hexlify(c2)) writer.close() The ciphertexts: c1 = \"3b6ccd7fa1de0455945998bc024adc6c2b60ccc8f020cbf024c3d4f98eafdf6a43afd15ec4d9a32f84cb61f7a5462547f2e3622b547c3e9ccb723102805544b373a80f4d252a1081db6d5c5499b222093fd4bb7997c68ab0ed8a9ac3bd0dae64cdfb946da1e311ef6e216ddf2dac14ea3710d5622269f08073598c24a3000a6dd6270ca0db5c304102bc9a5cd104484a2c0ced339121f13499c795de343ad2e655d4ace726654ee9f110e4bee3db95d8e514bd6e658769a01638ff2e9ce954dc09def3b01f6d598ddae2ca9735c8e8f9b71c96984a114084fb0a25b3646481e8c8d4d8adfedc7afad7be7a009c6d12753db4216ab9fd7fc8c37c819aef6a8bce\" c2 = \"998d5eeb0c048ade8cd807cb582b15a7799e8481a7476dbe8e0310b5ffc5161add92539bc0a374333c11f5f2008195782a44e45f2394fe3115af59fbc73ad24c4d084d79ba8e5896b644917335fd9a0e07c1d1d316e50480ba44c67b6fc04a2ce33dbc721768f1f874ff2ce1ec0503a4a7c67d10119ff9f79030459068de24ff24593e16877fd74c5a12d0e64a3d62e61b13c403aad2fe605601e8a097aba99707e305e3125a3c89f3d6beccc2f19a32fdac9ab7df181938b9b80d83a54c9c23ef11affff0fca67ecd9d45c58ece90a44ecd60aff7be05bf97cb554c563a3f9139d99f7c76a07acaaa261b1d6cb41e228fb2aca02ed1c64d468aabb8cfaa9210\" It seems that the encryption of the first and the last half of flag is not relevant. But at least we should check the public key and the modulus of key1.pem and key2.pem. from Crypto.PublicKey import RSA key1 = RSA.import_key(open('breaking_news\\key1.pem','rb').read()) key2 = RSA.import_key(open('breaking_news\\key2.pem','rb').read()) e1 = key1.e e2 = key2.e n1 = key1.n n2 = key2.n e1 (bit_length = 2045): 2726678763069742290493975678771854042946997886526658885273589794982550850524484749274268692898909814780790152954912126546903921714367517303032050244891472514523849708519935681313568761427297382724990480371626349446130805480456004417663238567505831802110513475009108333474503714942886902760554023856774744528158730164306665386046820676766827602146514316823937019543742466850364749529076296428648908924805389552335245924389342424467024736023185451341764743413642429057857014342930366786601460889647066379811076861622890568687138322791084455379633576246829677348537342669805283721207716632578516825617674863582898823857 n1 (bit_length = 2048): 22446667384135380364728550075881381726053468195188168013152415796352249451953078762739428049146187827398120100488504055606635548019009256889092903583429161620832130884808020463159053237738268615549212998960185401460575049040129569674912795281010462969369309454450379821434551440286230754665181962106098655531061808191857271372118647412341530534507363035768520018955713235360762429287435263772391386477249961479679573552073377992778864273735159890546438757223394182339510136036600928909879322891169743059815434712294601960066048614718984000476293007036534025674690519367295530441293542361110626472198678166093083778539 e2 (bit_length = 2047): 1025614691538937680473350384937839404022673831543804873390821235642349784468976380689985141971347728145167220859932279361921851630754436084881310527467399581064169495199510518576682055075870988700464507436921496419813225182888368322755063851582948247904399276524553429044729402973825513752800743408745783376473721224429168610790081938366519110824829336786992193261655888040783602954129146564842167332117396899423321041617438046837454077677830936561","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:0:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"The first half I tried and happily it’s broken by the Wiener Attack. For the Wiener Attack, readers should read this. Here is the code: import owiener N = n1 try: d1 = owiener.attack(e1, N) k1 = RSA.construct((N, e1, d1)) cryptor1 = PKCS1_OAEP.new(k1) c1 = bytes.fromhex(c1) print(cryptor1.decrypt(c1)) except: print(\"Failed\") The library owiener is in this repo. Result: b'ENO{n3ver_reus3_your_pr1mes_4_a_' ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:1:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"The last half The last half is not that easy. I tried the same attack and it failed. But maybe we can exploit some properties from known key (e1, d1) in the previous section. Fortunately, it does! Based on this paper of Prof. Dan Boneh, the factorization of $N$ can be computed in polynomial time when we’re given one pair (e, d). One implementation of this fast-factor algorithm is available in this repo. I made a tiny optimization in operator to make it works with big numbers, you can try to guess what it is, hehe. Here is the code: p, q = factor(N, e1, d1) phi = (p - 1) * (q - 1) d2 = inverse(e2, phi) k2 = RSA.construct((N, e2, d2)) cryptor2 = PKCS1_OAEP.new(k2) print(cryptor1.decrypt(c1) + cryptor2.decrypt(c2)) The final result: b'ENO{n3ver_reus3_your_pr1mes_4_a_new_k3y_you_have_2_p4y_th3_pr1ce}' ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:2:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Writeups"],"content":"Conclusion This challange is very helpful to me, because it contains many (2) important attacks that I forgot. It’s a nice chance to review RSA! ","date":"2023-03-10","objectID":"/dashaus165blog/breaking-news/:3:0","tags":["writeups","crypto","nullcon2023"],"title":"nullcon HackIM CTF Berlin 2023: breaking news","uri":"/dashaus165blog/breaking-news/"},{"categories":["Mathematics"],"content":"\rNote\rThis article is written by chatGPT. This is for catergories testing purpose.\rIntroduction to Finite Fields Finite fields, also known as Galois fields, are algebraic structures that are widely used in many areas of mathematics, including cryptography, coding theory, and number theory. In this article, we will introduce the basics of finite fields and explore some of their properties. ","date":"2023-03-02","objectID":"/dashaus165blog/eigenvalues_and_eigenvectors/:0:0","tags":["math","mathematic"],"title":"Introduction to Finite Fields","uri":"/dashaus165blog/eigenvalues_and_eigenvectors/"},{"categories":["Mathematics"],"content":"Definition A finite field is a field that contains a finite number of elements. More formally, a finite field is a field $(F, +, \\cdot)$ where $F$ is a finite set of elements, and $+$ and $\\cdot$ are binary operations on $F$ that satisfy the following axioms: $(F, +)$ is an abelian group. $(F\\setminus{0}, \\cdot)$ is an abelian group. The distributive law holds: $a\\cdot (b+c) = a\\cdot b + a\\cdot c$ for all $a,b,c\\in F$. In other words, a finite field is a field where addition and multiplication are well-defined, and where the set of elements is finite. ","date":"2023-03-02","objectID":"/dashaus165blog/eigenvalues_and_eigenvectors/:1:0","tags":["math","mathematic"],"title":"Introduction to Finite Fields","uri":"/dashaus165blog/eigenvalues_and_eigenvectors/"},{"categories":["Mathematics"],"content":"Examples There are many examples of finite fields, but perhaps the most well-known is the field of integers modulo a prime $p$. This field is denoted by $\\mathbb{F}_p$, and consists of the integers $0, 1, 2, \\ldots, p-1$. Addition and multiplication are performed modulo $p$, so that for example $5 + 7 \\equiv 0 \\pmod{12}$ and $3 \\cdot 4 \\equiv 0 \\pmod{12}$. It can be shown that $\\mathbb{F}_p$ is a field under these operations. Another example of a finite field is the field of integers modulo a power of a prime. For example, the field $\\mathbb{F}_{p^2}$ consists of the polynomials of degree at most 1 with coefficients in $\\mathbb{F}_p$, i.e. the set ${0, 1, x, x+1}$ where addition and multiplication are performed modulo $p$ and with the rule $x^2 = x+1$. This field is also a finite field. ","date":"2023-03-02","objectID":"/dashaus165blog/eigenvalues_and_eigenvectors/:2:0","tags":["math","mathematic"],"title":"Introduction to Finite Fields","uri":"/dashaus165blog/eigenvalues_and_eigenvectors/"},{"categories":["Mathematics"],"content":"Properties Finite fields have many interesting properties that make them useful in various applications. Here are some of the most important properties: Every finite field has a prime power order. That is, if $F$ is a finite field with $q$ elements, then $q=p^n$ for some prime $p$ and some positive integer $n$. Conversely, every field of order $p^n$ is isomorphic to the field of integers modulo $p^n$. Finite fields are unique up to isomorphism. That is, if $F$ and $F’$ are two finite fields with the same number of elements, then there exists an isomorphism $\\phi:F\\to F’$. Addition and multiplication tables for a finite field can be represented by a matrix of size $q\\times q$, where $q$ is the number of elements in the field. These matrices have many interesting properties, including being invertible and having a non-zero determinant. The non-zero elements of a finite field form a cyclic group under multiplication. This group is generated by a primitive element of the field, i.e. an element $g$ such that every non-zero element of the field can be expressed as a power of $g$. ","date":"2023-03-02","objectID":"/dashaus165blog/eigenvalues_and_eigenvectors/:3:0","tags":["math","mathematic"],"title":"Introduction to Finite Fields","uri":"/dashaus165blog/eigenvalues_and_eigenvectors/"},{"categories":["Mathematics"],"content":"Conclusion Finite fields are fascinating algebraic structures with many interesting properties. They are used in a wide range of applications, including coding theory, cryptography, and number theory. ","date":"2023-03-02","objectID":"/dashaus165blog/eigenvalues_and_eigenvectors/:4:0","tags":["math","mathematic"],"title":"Introduction to Finite Fields","uri":"/dashaus165blog/eigenvalues_and_eigenvectors/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/dashaus165blog/about/","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Some Background Informations I am Hao Pham-Duc (dasHaus165), a Cryptographer from the Bach Khoa Information Security Club (BKISC), Ho Chi Minh City University of Technology (HCMUT). ","date":"0001-01-01","objectID":"/dashaus165blog/about/:1:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Interests Applied Cryptography Machine Learning Classical and Quantum Physics ","date":"0001-01-01","objectID":"/dashaus165blog/about/:2:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Achievements Nothing yet. ","date":"0001-01-01","objectID":"/dashaus165blog/about/:3:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"},{"categories":null,"content":"Contact Me You can contact me via Email or Github. ","date":"0001-01-01","objectID":"/dashaus165blog/about/:4:0","tags":null,"title":"About Me","uri":"/dashaus165blog/about/"}]